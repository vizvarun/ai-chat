import { GenerateResponse } from "../../types/testTypes";
import { encodeHtml, markdownToHtml } from "../../utils/textProcessing";
import axiosInstance from "./axios";
import { API_ENDPOINTS } from "../../config/env";

// Define interface but export it to avoid the "declared but never used" warning
export interface GenerateTestCasesRequest {
  storyTitle: string;
  storyDescription: string;
}

// Default mock data as fallback
const defaultResponse: GenerateResponse = {
  testPlans: [
    {
      title: "Default Test Plan",
      description: "No test plan was generated by the API",
      steps: ["Review requirements", "Identify test cases", "Execute tests"],
    },
  ],
  testCases: [],
};

export const testCasesService = {
  generateTestCases: async (
    storyTitle: string,
    storyDescription: string
  ): Promise<GenerateResponse> => {
    try {
      const response = await axiosInstance.post<any>(
        API_ENDPOINTS.GENERATE_TEST_CASES,
        {
          storyTitle,
          storyDescription,
        }
      );

      // Validate response structure
      const data = response.data;
      if (!data) {
        console.error("Empty API response");
        return defaultResponse;
      }

      // Process the API response to match our expected format
      return processApiResponse(data);
    } catch (error) {
      console.error("Error generating test cases:", error);
      throw error;
    }
  },

  exportTestCasesToExcel: async (testCases: any[]): Promise<Blob> => {
    try {
      const response = await axiosInstance.post(
        API_ENDPOINTS.DOWNLOAD_EXCEL,
        { data: testCases }, // Changed key from 'testCases' to 'data'
        { responseType: 'blob' }
      );
      
      return response.data;
    } catch (error) {
      console.error("Error exporting Excel:", error);
      throw error;
    }
  }
};

// Helper function to process API response and ensure it matches expected format
function processApiResponse(data: any): GenerateResponse {
  // If the response is completely malformed, return default data
  if (!data) return defaultResponse;

  const processed: GenerateResponse = {
    testCases: [],
    testExecutionPlan: undefined,
    testPlans: [],
  };

  // Process test cases - should be an array of objects
  if (data.testCases && Array.isArray(data.testCases)) {
    processed.testCases = data.testCases.filter(
      (tc: any) => tc && typeof tc === "object" && tc["Test Case ID"]
    );
  }

  // Process test execution plan if available
  if (data.testExecutionPlan && typeof data.testExecutionPlan === "string") {
    // First encode the raw text to prevent XSS
    const encodedText = encodeHtml(data.testExecutionPlan.trim());

    // Convert encoded markdown to HTML
    processed.testExecutionPlan = markdownToHtml(encodedText);

    // Generate a test plan from the execution plan string
    // Use the original text for steps, but encode each step
    processed.testPlans = [
      {
        title: "Test Execution Plan",
        description: "Generated from the test execution plan",
        steps: data.testExecutionPlan
          .trim()
          .split("\n")
          .filter((line: string) => line.trim() !== "")
          .map((line: string) => encodeHtml(line.trim())),
      },
    ];
  }

  // If the API returns testPlans directly, use those instead
  if (data.testPlans && Array.isArray(data.testPlans)) {
    processed.testPlans = data.testPlans.map((plan: any) => ({
      title: plan.title || "Untitled Test Plan",
      description: plan.description || "No description available",
      steps: Array.isArray(plan.steps)
        ? plan.steps.map((step: string) => encodeHtml(step))
        : [],
    }));
  }

  // If no test cases were found, provide empty array
  if (!processed.testCases.length) {
    processed.testCases = [];
  }

  // If no test plans and no execution plan, use default
  if (!processed.testPlans?.length && !processed.testExecutionPlan) {
    processed.testPlans = defaultResponse.testPlans;
  }

  return processed;
}
